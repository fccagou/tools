#!/usr/bin/env python
# -*- encoding: utf-8 -*-
"""
Local Dashboard for easy configuration.

The aim is to give access for some tools from webbrowser

- Read commande list from config files

  - system config
  - user config

- Access from web page
- application runs with user right
- Allow use to add own application
- Can run graphical applications



"""

from __future__ import print_function

import os
import ssl
import sys
import json
import stat
import time
import signal
import logging
import mimetypes
import subprocess
import wsgiref.simple_server as server

from threading import Thread


# -----------------------------------------------------------------
#  python wrapper
# -----------------------------------------------------------------
try:
    # For Python 3.0 and later
    from urllib.request import urlopen
    MYURLOPEN = lambda url, timeout, context: urlopen(url=url, timeout=timeout, context=context)
except ImportError:
    # Fall back to Python 2's urllib2
    from urllib2 import urlopen
    MYURLOPEN = lambda url, timeout, context: urlopen(url=url, timeout=timeout)

def wsgi_to_bytes(str2convert):
    """
    Because of https://www.python.org/dev/peps/pep-3333/#unicode-issues
    """
    return str2convert.encode('iso-8859-1')


try:
    from secrets import token_hex
except:
    # Code from lib/secrets.py
    # https://github.com/python/cpython/blob/3.6/Lib/secrets.py
    #
    import binascii

    DEFAULT_ENTROPY = 32  # number of bytes to return by default

    def token_bytes(nbytes=None):
        """Return a random byte string containing *nbytes* bytes.
        If *nbytes* is ``None`` or not supplied, a reasonable
        default is used.
        >>> token_bytes(16)  #doctest:+SKIP
        b'\\xebr\\x17D*t\\xae\\xd4\\xe3S\\xb6\\xe2\\xebP1\\x8b'
        """
        if nbytes is None:
            nbytes = DEFAULT_ENTROPY
        return os.urandom(nbytes)

    def token_hex(nbytes=None):
        """Return a random text string, in hexadecimal.
        The string has *nbytes* random bytes, each byte converted to two
        hex digits.  If *nbytes* is ``None`` or not supplied, a reasonable
        default is used.
        >>> token_hex(16)  #doctest:+SKIP
        'f9bf78b9a18ce6d46a0cd2b0b86df9da'
        """
        return binascii.hexlify(token_bytes(nbytes)).decode('ascii')



# -----------------------------------------------------------------
# Global Variables.
# -----------------------------------------------------------------
# Default web server listening port
LISTENING_PORT = 8080

# For debuging
verbose = False

# Document Root for static web pages.
document_root = '/etc/mydashboard/html'

# ssl context for unverified site.
ssl_default_ctx = None

# Script used for rdp connection
remote_connection_script = 'data/remote_connection.sh'

# Default remote_list for demo
remotelist_conf = 'data/remote.json'

# debug flag
debuging = False

# default debug file
debug_filename = '~/mydash.log'

# COnfiguration file
conf_file=None

# token file name
token_filename = '~/.mydashboard'

# Current tocken session
#
MYTOKEN=token_hex(16)

# Safe mode if token is used
use_token=True


# -----------------------------------------------------------------
# Informational functions.
# -----------------------------------------------------------------
def log(msg):
    global verbose
    if verbose:
        print("[+] - ", msg)
    else:
        pass

def info(msg):
    global verbose
    if verbose:
        print("[i] - ", msg)
    else:
        pass

def warning(msg):
    global verbose
    if verbose:
        print("[!] - ", msg)
    else:
        pass

def error(msg):
    global verbose
    if verbose:
        print("[-] - ", msg)
    else:
        pass

def debug(msg):
    global debuging
    if debuging:
        logging.debug(msg)

# -----------------------------------------------------------------
# HTTP: default page showing all notifiers status.
# -----------------------------------------------------------------

def page(start_response, output, ctype='text/plain', status="200 OK" ):
    global ssl_default_ctx

    response_headers = [('Content-type', ctype),
                        ('Content-Length', str(len(output)))]
    start_response(status, response_headers)
    return [output]


def static_page(start_response, filename, fullpath=False):
    global ssl_default_ctx
    global document_root

    status = "200 OK"

    try:
        if fullpath:
            real_file_path = os.path.expanduser(filename)
        else:
            real_file_path = os.path.join(document_root,filename)
        output = open(real_file_path, 'rb').read()
        ctype = mimetypes.guess_type(real_file_path)[0]
    except:
        status = "500 INTERNAL ERROR"
        import traceback
        warning("INTERNAL ERROR: %s " %  sys.exc_info()[0])
        print('-'*60)
        traceback.print_exc(file=sys.stdout)
        print('-'*60)
        output = "The code seems to have an internal error :("
        ctype = 'text/plain; charset=UTF-8'

    return page(start_response, output, ctype=ctype, status=status)


def jsonapi(start_response, data):
    global ssl_default_ctx

    status = "200 OK"

    try:
        import json
        output = json.dumps(data)
        ctype='application/json; charset=UTF-8'
    except:
        status = "500 INTERNAL ERROR"
        import traceback
        warning("INTERNAL ERROR: %s " %  sys.exc_info()[0])
        print('-'*60)
        traceback.print_exc(file=sys.stdout)
        print('-'*60)
        output = "The code seems to have an internal error :("
        ctype = 'text/plain; charset=UTF-8'

    return page(start_response, wsgi_to_bytes(output), ctype=ctype, status=status)

def doc(start_response):

    global LISTENING_PORT
    global token_filename

    service_user_dir = os.path.expanduser('~/.config/systemd/user')
    service_name = os.path.sep.join((service_user_dir, 'mydashboard.service'))

    output = """

Liste des actions possibles
===========================

/ui : Lance firefox et se connect au microservice

/remote/list : Liste de machines accessibles via rdp  (json)

/systemd/service : Genere le script de service a mettre en userland

  Exemple d'utilisation

      mkdir -p %s
      curl -b "MYTOKEN=$(cat %s)" --silent http://localhost:%s/systemd/service -o %s
      systemctl --user enable mydashboard
      systemctl --user start mydashboard

""" % (service_user_dir, token_filename, LISTENING_PORT, service_name )
    return page(start_response, wsgi_to_bytes(output), ctype='text/plain', status='200 OK')



def systemd_service_display(start_response):

    global conf_file
    global document_root

    if conf_file is None:
        dash_option = "-D %s" % document_root
    else:
        dash_option = "--conf %s" % conf_file

    prg_name = os.path.abspath(os.path.expanduser(sys.argv[0]))

    if 'DISPLAY' in os.environ:
        display = os.environ['DISPLAY']
    else:
        display = ':0'

    if 'LANG' in os.environ:
        lang = os.environ['LANG']
    else:
        lang = 'fr_FR.UTF-8'

    status = '200 OK'
    output = """[Unit]
Description=My dashboard MicroService

[Service]
Environment="DISPLAY=%s" "LANG=%s"
ExecStart=%s -d -v --fg --nopid  %s

[Install]
WantedBy=default.target
           """ % (display, lang, prg_name, dash_option)

    return page(start_response, wsgi_to_bytes(output), ctype='text/plain', status='200 OK')



def login_ok(start_response):
    global MYTOKEN

    status = '301 Moved Permanently'
    output = ''
    response_headers = [('Content-type', 'text/plain'),
                        ('Content-Length', str(len(output))),
                        ('Location', '/'),
                        ('Set-Cookie', "MYTOKEN=%s" % MYTOKEN),
                        ]
    start_response(status, response_headers)
    return wsgi_to_bytes(output)


def notfound(start_response, url):

    status = '404 NOT FOUND'
    output = "%s not found\n" % url
    return page(start_response, wsgi_to_bytes(output), ctype='text/plain', status=status)



def run_cmd(cmd_set):
    pid = os.fork()
    if pid == 0:
        #subprocess.run(("/usr/bin/gnome-terminal -- %s" % cmd_set[0] ), shell=True)
        # PYTHON3 subprocess.run(("/usr/bin/gnome-terminal"), shell=True)
        debug("CMD : %s\n" % (cmd_set))
        p=subprocess.Popen(cmd_set, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate()
        # Decouple from parent environment
        os.setsid()
        # TODO os.umask()
        # Redirect the standard I/O file descriptors to /dev/null
        if hasattr(os, "devnull"):
             REDIRECT_TO = os.devnull
        else:
             REDIRECT_TO = "/dev/null"

        fd = os.open(REDIRECT_TO, os.O_RDWR)
        os.dup2(fd, 0)  # standard input (0)
        os.dup2(fd, 1)  # standard output (1)
        os.dup2(fd, 2)  # standard error (2)

	# Ajouter cela dans un message sur l'interface.
        # ret_msg = '---\n'.join([(out or ''), (err or '')])
        if p.wait() != 0:
            debug("ERR:\n%s\n%s\n" % (out, err))
        else:
            debug("SUCCESS\n%s\n%s\n" % (out, err))

        os._exit(0)


# -----------------------------------------------------------------
# HTTP: WEB APP
# -----------------------------------------------------------------
def application(environ, start_response):

    global MYTOKEN
    global use_token

    if environ['PATH_INFO'][1:] == MYTOKEN:
        return login_ok(start_response)

    if use_token:
        try:
            cookies=environ['HTTP_COOKIE']
            log(cookies)
            if not MYTOKEN in cookies:
                raise Exception('')
        except:
            return page(start_response, output=wsgi_to_bytes("I'm a tea pots"),
                    status="418 I'm a teapot")

    if environ['PATH_INFO'] in ['/bootstrap.min.css', '/jquery.min.js', '/bootstrap.bundle.js', '/computer.png', '/mydashboard.js']:
        return static_page(start_response, environ['PATH_INFO'][1:])

    if environ['PATH_INFO'] == "/doc":
        return doc(start_response)

    if environ['PATH_INFO'] == "/ui":
        global LISTENING_PORT
        run_cmd(["/usr/bin/firefox http://localhost:%s/%s" % (LISTENING_PORT,MYTOKEN)])

    elif environ['PATH_INFO'] == "/top":
        run_cmd(["/usr/bin/top"])

    elif environ['PATH_INFO'] == "/systemd/service":
        return systemd_service_display(start_response)

    elif environ['PATH_INFO'] == "/remote/list":
        global remotelist_conf
        return static_page(start_response, remotelist_conf ,fullpath=True )

    elif environ['PATH_INFO'][0:8] == "/remote/":
        (site,domain,group,remote_host) = environ['PATH_INFO'][8:].split('/')
        global remote_connection_script
        run_cmd(["%s %s %s %s %s nla "
            % (remote_connection_script, site, domain, group, remote_host) ])

    else:
        # TODO: passer un message d'erreur
        True


    return static_page(start_response, 'template.html')


# -----------------------------------------------------------------
# MAIN PROGRAM.
# -----------------------------------------------------------------
def EndException(BaseException):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def end_process(signum, frame):
    raise EndException('Signal catch')



def main(args):

    global verbose
    global debuging
    global use_token
    global remotelist_conf
    global conf_file
    global document_root
    global debug_filename
    global ssl_default_ctx
    global token_filename
    global remote_connection_script
    global LISTENING_PORT

    verbose = args.verbose
    debuging = args.debug



    # Catch signal to quit cleanly.
    signal.signal(signal.SIGTERM, end_process)
    signal.signal(signal.SIGQUIT, end_process)

    if debuging:
        log("args list: %s " %  args)

    # Get configuration from file.
    if args.conf is not None:
        conf_file = os.path.expanduser(args.conf)
        log('Using config file %s' % conf_file)
        conf = json.loads(open(conf_file, 'r').read())

        if 'documentroot' in conf:
            document_root = conf['documentroot']

        if 'ssl_allow_unverified' in conf and conf['ssl_allow_unverified'] == "True":
            ssl_default_ctx = ssl._create_unverified_context()

        if 'remote_connection' in conf:
           remote_connection_script = conf['remote_connection']

        if 'remotelist' in conf:
           remotelist_conf = conf['remotelist']

        if 'debug_filename' in conf:
           debug_filename = conf['debug_filename']

        if 'token_filename' in conf:
            token_filename = conf['token_filename']



    if args.documentroot:
        document_root = args.documentroot
    document_root = os.path.abspath(os.path.expanduser(document_root))

    if args.remotecnx:
        remote_connection_script = args.remotecnx
    remote_connection_script = os.path.abspath(os.path.expanduser(remote_connection_script))

    if args.debugfilename:
        debug_filename = args.debugfilename
    debug_filename = os.path.abspath(os.path.expanduser(debug_filename))
    logging.basicConfig(filename=debug_filename,level=logging.DEBUG)


    if args.remotelist:
        remotelist_conf = args.remotelist
    remotelist_conf = os.path.abspath(os.path.expanduser(remotelist_conf))

    token_filename = os.path.abspath(os.path.expanduser(token_filename))
    use_token = not args.notoken


    # TODO: valider l'existence des scripts

    if debuging:
        log("debug file               : %s" % debug_filename)
        log("remotelist_conf          : %s" % remotelist_conf)
        log("document_root            : %s" % document_root)
        log("remote_connection_script : %s" % remote_connection_script)
        if use_token:
            log("token_filename       : %s" % token_filename)
            log("MYTOKEN              : %s" % MYTOKEN)

    if not use_token:
        warning('UNSAFE MODE')
    else:
        try:
            with open(token_filename, 'w') as f:
                f.write(str(MYTOKEN))
        except:
            error("unable to write token in file %s" % token_filename)
            return

        try:
            os.chmod(token_filename, stat.S_IRUSR|stat.S_IWUSR)
        except:
            error("Unable to set rights 600 on file %s" % token_filename)

    stop_thread = False
    try:
        LISTENING_PORT = args.port
        httpd = server.make_server('', LISTENING_PORT, application)
        log("Serving HTTP on port %i..." % LISTENING_PORT)
        # Respond to requests until process is killed
        httpd.serve_forever()
    except KeyboardInterrupt:
        log('End asked by user...bye bye !')
    except EndException as ee:
        log(ee.value)
    except:
        print("Unexpected error:", sys.exc_info()[0])
    finally:
        # Ending all process and switch notifiers off before leaving.
        stop_thread = True

        log("Waiting end of process")
        time.sleep(2)

if __name__ == '__main__':


    # Process passed arguments.
    try:
        import argparse
        parser = argparse.ArgumentParser(
            description='Notify processor.',
            )
        USING_ARGPARSE = True
    except ImportError:
        import optparse
        parser = optparse.OptionParser(
            description='PYthon Alert Processor.')
        parser.parse_args_orig = parser.parse_args
        parser.parse_args = lambda: parser.parse_args_orig()[0]
        parser.add_argument = parser.add_option
        USING_ARGPARSE = False

    parser.add_argument('--conf', '-c',
                        help='Configuration file.')
    parser.add_argument('--port', '-p', default=LISTENING_PORT, type=int,
                        help='Listening port for status push .')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Verbose.')
    parser.add_argument('--debug', '-d', action='store_true',
                        help='Debug mode.')
    parser.add_argument('--debugfilename', default=None,
                        help='Debug file name mode.')
    parser.add_argument('--fg', action='store_true',
                        help='Forground mode. Disable daemon mode.')
    parser.add_argument('--nopid', action='store_true',
                        help='Disable writing pid file (see --pidfile)')
    parser.add_argument('--pidfile', default='/var/run/pyap.pid',
                        help='Set the pid file.')
    parser.add_argument('--documentroot', '-D', default=None,
                        help='Document root for static web pages.')
    parser.add_argument('--remotelist', '-R', default=None,
                        help='Url to json remote list')
    parser.add_argument('--remotecnx', '-C', default=None,
                        help='Remote connection script')
    parser.add_argument('--notoken', action='store_true',
                        help='Unsafe mode without token.')

    args = parser.parse_args()




    if not args.fg:
        # do the UNIX double-fork magic, see Stevens' "Advanced
        # Programming in the UNIX Environment" for details (ISBN 0201563177)
        if args.debug or args.verbose:
            log('Running daemon mode.')

        if os.fork() > 0:
            sys.exit(0)

        # Decouple from parent environment
        os.chdir('/')
        os.setsid()
        # TODO os.umask()
        # Redirect the standard I/O file descriptors to /dev/null
        if hasattr(os, "devnull"):
            REDIRECT_TO = os.devnull
        else:
            REDIRECT_TO = "/dev/null"

        fd = os.open(REDIRECT_TO, os.O_RDWR)
        os.dup2(fd, 0)  # standard input (0)
        os.dup2(fd, 1)  # standard output (1)
        os.dup2(fd, 2)  # standard error (2)

        # Double-fork magic must be single-fork for systemd
        # TODO: test under centos6 using init.
        # if os.fork() > 0:
        #     sys.exit(0)

    if not args.nopid:
        with open(args.pidfile, 'w') as f:
            f.write(str(os.getpid()))

    main(args)

    if not args.nopid:
        os.remove(args.pidfile)

    os._exit(os.EX_OK)
