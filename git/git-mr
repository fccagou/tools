#!/usr/bin/bash

set -eu
set -o pipefail

[ "$TERM" = "screen" ] && TERM=xterm-256color

# Variables
if tput setaf 1 &> /dev/null; then
  tput sgr0 &>/dev/null ; # reset colors
  bold=$(tput bold);
  reset=$(tput sgr0);
  # Solarized colors, taken from http://git.io/solarized-colors.
  black=$(tput setaf 0);
  blue=$(tput setaf 33);
  cyan=$(tput setaf 37);
  green=$(tput setaf 64);
  orange=$(tput setaf 166);
  purple=$(tput setaf 125);
  red=$(tput setaf 124);
  violet=$(tput setaf 61);
  white=$(tput setaf 15);
  yellow=$(tput setaf 136);
  grey=$(tput setaf 230);
else
  bold="";
  reset="\\e[0m";
  # shellcheck disable=SC2034
  black="\\e[1;30m";
  blue="\\e[1;34m";
  cyan="\\e[1;36m";
  green="\\e[1;32m";
  # shellcheck disable=SC2034
  orange="\\e[1;33m";
  # shellcheck disable=SC2034
  purple="\\e[1;35m";
  red="\\e[1;31m";
  violet="\\e[1;35m";
  white="\\e[1;37m";
  yellow="\\e[1;33m";
  grey="${white}"
fi;

RESTORE='\e[0m'
RED='\e[31m'
GREEN='\e[38;5;64m'
YELLOW='\e[33m'
BLUE='\e[34m'

COLOR_CHAPTER='\e[33;48;5;52m['
COLOR_TITLE1='\e[7;49;37m['
COLOR_ERROR=${RED}
COLOR_INFO=${BLUE}
COLOR_ACTION=${GREEN}
COLOR_WARNING=${RED}
COLOR_TODO=${BLUE}

COLOR_COMPAT="${orange}"
COLOR_3DOT="${blue}"


# ===================================================================================================
#  Gestion des erreurs + aide
# ===================================================================================================

chapter  () {
	printf -- "${COLOR_CHAPTER}% 100s\r[#] %s${RESTORE}\n" " " "${*}"
}

title1  () {
	printf -- "${COLOR_TITLE1}% 100s\r |  %s${RESTORE}\n" " " "${*}"
}


error () {
	printf -- "${COLOR_ERROR}[-] %s${RESTORE} \n" "${*}"
}

warning () {
	printf -- "${COLOR_WARNING}[!]${RESTORE} %s\n" "${*}"
}

action () {
	printf -- "${COLOR_ACTION}[+] %s${RESTORE}\n" "${*}"
}


info () {
	printf -- "${COLOR_INFO} |->${RESTORE} %s\n" "${*}"
}

todo () {
	printf -- "${COLOR_TODO}[ ] TODO: %s${RESTORE}\n" "${*}"
}


usage () {
    cat <<EOF_USAGE
usage: $(basename "$0") [help] [CMD] [remote] [CMD OPTIONS]

CMD

    list               : list all mr for a remote (default: origin)
    fetch              : fetch all mr for a remote (default: origin)
    status             : show commit list between <remote>/main and <remote>/#mr
    show               : show commits between <remote>/main and <remote>/#mr
    rebase             : rebase mr to <remote>/main
    push               : push mr to <remote>

LIST OPTIONS

    --without-branch   : list all mr

STATUS-REBASE-PUSH  OPTIONS

    no option          : all mr from remote origin
    <remote>           : all mr from remote <remote>

    <remote> #mr       : \\
    mr/<remote>/#mr    : |-  common format
    <remote>/#mr       : /

    #mr                : link to mr/origin/#mr

SHOW OPTIONS

    <remote> #mr       : \\
    mr/<remote>/#mr    : |-  common format
    <remote>/#mr       : /

    #mr                : link to mr/origin/#mr

EOF_USAGE
}

mr_help() {
    usage
}

mr_get_remote () {
	local remote
	remote="$1"
	git ls-remote "$remote" "refs/merge-requests/*/head" \
		| awk '{ print $2 }'
}

mr_remote_branch () {
	local remote
    local mr

    remote="$1"
    mr="$2"

    git branch --list --remote --points-at="$(git rev-parse --short "$mr")" \
        | grep "$remote" \
        | cut -d/ -f2- \
        | grep -vE '^(HEAD|main)' \
    || echo ""
}

mr_list () {
    local remote
    local verbose

    remote="$1"
    showbranch="yes"

    [ "$remote" == "--without-branch" ] && { remote=origin; showbranch="no"; }

    git remote | grep -q "^${remote}$" || {
        error "Unknown remote ${remote}"
        exit 1
    }

    [ "$#" -ge "2" ] && [ "$2" == "--without-branch" ] && showbranch="no"

    if [ "$showbranch" == "no" ]; then
        git branch --list "mr/${remote}/*"
    else
        git branch --list "mr/${remote}/*" | while read mr; do
            remote_mr_branch="$(mr_remote_branch "$remote" "$mr")"
            printf -- "%s %s\n" "$mr" "${remote_mr_branch}"
        done
    fi
}

mr_fetch () {
    local remote
    local ref
    remote="$1"

	fetchpattern='+refs/merge-requests/*/head:refs/heads/mr/'"$remote"'/*'
        git config --get-all remote."$remote".fetch \
		| grep -qF "${fetchpattern}" \
		|| git config --add remote."$remote".fetch "$fetchpattern"

	git fetch "$remote" --prune
}


mr_status () {
    local remote
    local mr
    local _mr

    remote="$1"
    mr="$2"

	remote_origin_commit="$(git rev-parse "$remote"/main)"

	{
		[ -n "$mr" ] && echo "$mr" || mr_list "$remote" --without-branch
	} | while read _mr; do

          remote_mr_branch="$(mr_remote_branch "$remote" "$_mr")"
          [ -z "${remote_mr_branch}" ] || {
              chapter "${_mr} -> ${remote}/${remote_mr_branch}"
              git log --no-merges --color --pretty=format:' * %Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an (%G?)>%Creset' --abbrev-commit  "$remote"/main.."$_mr"
              if [ "$(git merge-base "$remote"/main "$_mr")" != "${remote_origin_commit}" ]; then
                  info "need rebase"
                  todo "git mr rebase ${_mr}"
              else
                  printf -- "/\n"
                  git branch --list --format="* %(refname:short)    %(subject)" main
              fi
		  }
        done
}


mr_show () {
    local remote
    local mr
    local _mr

    remote="$1"
    mr="$2"

	if [ -z "$mr" ]; then
		error "You must provide the review number"
	else
       remote_mr_branch="$(mr_remote_branch "$remote" "$mr")"
       [ -z "${remote_mr_branch}" ] || {
           chapter "${mr} -> ${remote}/${remote_mr_branch}"
           git show "$remote"/main.."$mr"
	   }

	fi
}


mr_rebase () {
    local remote
    local mr
    local remote_mr_branch

    remote="$1"
    mr="$2"

    {
        [ -n "$mr" ] && echo "$mr" || mr_list "$remote" --without-branch
    } | while read _mr; do
            remote_mr_branch="$(mr_remote_branch "$remote" "$_mr")"
            action "rebase ${remote_mr_branch} on $remote/main"
            todo "implementation"
        done
}

mr_push () {
    local remote
    local mr

    local remote_mr_branch
    local remote_origin_commit

    remote="$1"
    mr="$2"
	remote_origin_commit="$(git rev-parse "$remote"/main)"
    {
        [ -n "$mr" ] && echo "$mr" || mr_list "$remote" --without-branch
    } | while read _mr; do
            remote_mr_branch="$(mr_remote_branch "$remote" "$_mr")"
            if [ -z "${remote_mr_branch}" ]; then
               : # no branch => no current work or maybe achived
            elif [ "$(git merge-base "$remote"/main "$_mr")" != "${remote_origin_commit}" ]; then
                error "${_mr} nead rebase"
                todo "git mr rebase ${_mr}"
            else
                action "${_mr} push ${remote_mr_branch} to $remote"
                todo "implementation"
            fi
        done
}

main () {

    [ "$#" == "0" ] && action=list || { action="$1"; shift; }


    case "$action" in
        list|fetch)
            [ "$#" == "0" ] && remote="origin" || { remote="$1"; shift; }
            mr_"$action" "$remote" "$@"
            ;;
        status|show|rebase|push)
            if [ "$#" == "0" ]; then
                remote=origin
                mr=""
            else
                # remote <nb>
                # mr/remote/nb
                # remote/nb
                # nb
                if git remote | grep -q "^${1}$"; then
                    remote="$1"
                    [ "$#" -ge "2" ] && mr="mr/$remote/$2" || mr=""
                else
                    remote=""
                    mr="$1"
                fi

                if [ -n "$mr" ]; then
                    # check if mr format is  mr/<remote>/nb
                    IFS=/ read -r -a tmp <<<"$mr"

                    case ${#tmp[@]} in
                        1)
                            remote="origin"
                            mr=mr/origin/"${tmp[0]}"
                            ;;
                        2)
                            remote="${tmp[0]}"
                            mr=mr/"${tmp[0]}"/"${tmp[1]}"
                            ;;
                        3)
                            remote="${tmp[1]}"
                            mr=mr/"${tmp[1]}"/"${tmp[2]}"
                            ;;
                        *)
                            error "Bad branch format ($mr)"
                            usage
                            exit 1
                            ;;
                    esac
                    git branch | grep -q "^[ ]*${mr}$" || {
                        error "bad mr ($mr)"
                        mr_list "$remote"
                        exit 1
                    }
                fi

                git remote | grep -q "^${remote}$" || {
                    error "bad remote ($remote)"
                    git remotes
                    exit 1
                }
            fi
            mr_"$action" "$remote" "$mr"
            ;;
        help)
            mr_help
            ;;
        *)
            usage
            exit 1
            ;;
    esac

    exit 0
}



main "$@"
