#!/usr/bin/bash

set -eu
set -o pipefail

[ "$TERM" = "screen" ] && TERM=xterm-256color

# Variables
if tput setaf 1 &> /dev/null; then
  tput sgr0 &>/dev/null ; # reset colors
  bold=$(tput bold);
  reset=$(tput sgr0);
  # Solarized colors, taken from http://git.io/solarized-colors.
  black=$(tput setaf 0);
  blue=$(tput setaf 33);
  cyan=$(tput setaf 37);
  green=$(tput setaf 64);
  orange=$(tput setaf 166);
  purple=$(tput setaf 125);
  red=$(tput setaf 124);
  violet=$(tput setaf 61);
  white=$(tput setaf 15);
  yellow=$(tput setaf 136);
  grey=$(tput setaf 230);
else
  bold="";
  reset="\\e[0m";
  # shellcheck disable=SC2034
  black="\\e[1;30m";
  blue="\\e[1;34m";
  cyan="\\e[1;36m";
  green="\\e[1;32m";
  # shellcheck disable=SC2034
  orange="\\e[1;33m";
  # shellcheck disable=SC2034
  purple="\\e[1;35m";
  red="\\e[1;31m";
  violet="\\e[1;35m";
  white="\\e[1;37m";
  yellow="\\e[1;33m";
  grey="${white}"
fi;

RESTORE='\e[0m'
RED='\e[31m'
GREEN='\e[38;5;64m'
YELLOW='\e[33m'
BLUE='\e[34m'

COLOR_CHAPTER='\e[33;48;5;52m['
COLOR_TITLE1='\e[7;49;37m['
COLOR_ERROR=${RED}
COLOR_INFO=${BLUE}
COLOR_ACTION=${GREEN}
COLOR_WARNING=${RED}
COLOR_TODO=${BLUE}

COLOR_COMPAT="${orange}"
COLOR_3DOT="${blue}"


# ===================================================================================================
#  Gestion des erreurs + aide
# ===================================================================================================

chapter  () {
	printf -- "${COLOR_CHAPTER}% 100s\r[#] %s${RESTORE}\n" " " "${*}"
}

title1  () {
	printf -- "${COLOR_TITLE1}% 100s\r |  %s${RESTORE}\n" " " "${*}"
}


error () {
	printf -- "${COLOR_ERROR}[-] %s${RESTORE} \n" "${*}"
}

warning () {
	printf -- "${COLOR_WARNING}[!]${RESTORE} %s\n" "${*}"
}

action () {
	printf -- "${COLOR_ACTION}[+] %s${RESTORE}\n" "${*}"
}


info () {
	printf -- "${COLOR_INFO} |->${RESTORE} %s\n" "${*}"
}

todo () {
	printf -- "${COLOR_TODO}[ ] TODO: %s${RESTORE}\n" "${*}"
}


usage () {
    cat <<EOF_USAGE
usage: $(basename "$0") [help] [CMD] [remote] [CMD OPTIONS]

CMD

    list               : list all mr for a remote (default: origin)
    fetch              : fetch all mr for a remote (default: origin)
    log                : show logs between main and mr

LIST OPTIONS

    -q                 : quiet mode


EOF_USAGE
}

mr_help() {
    usage
}

mr_get_remote () {
	local remote
	remote="$1"
	git ls-remote "$remote" "refs/merge-requests/*/head" \
		| awk '{ print $2 }'
}

mr_list () {
    local remote
    local verbose

    remote="$1"
    verbose="-v"

    [ "$remote" == "-q" ] && { remote=origin; verbose=""; }

    git remote | grep -q "^${remote}$" || {
        error "Unknown remote ${remote}"
        exit 1
    }

    [ "$#" -ge "2" ] && [ "$2" == "-q" ] && verbose="" || verbose="-v"
    git branch --list "mr/${remote}/*" $verbose
}

mr_fetch () {
    local remote
	local ref
    remote="$1"

	fetchpattern='+refs/merge-requests/*/head:refs/heads/mr/'"$remote"'/*'
	git config get --all remote."$remote".fetch \
		| grep -qF "${fetchpattern}" \
		|| git config set --append remote."$remote".fetch "$fetchpattern"

	git fetch "$remote" --prune
}


mr_log () {
    local remote
    local mr

    remote="$1"
    shift

    [ "$#" == "1" ] && echo "$1" || mr_list "$remote" -q \
      | while read mr; do
          git log --oneline --abbrev-commit main^.."$mr" | wc -l | grep -q "^0$" || {
	             #printf -- "--------------------\n%s\n--------------------\n" "$mr"
		         branch="$(git branch -va \
					 | grep "$(git rev-parse --short "$mr")" \
					 | grep "remotes/${remote}/" \
					 | awk '{ print $1 }')"
                 chapter "$mr $branch"
				 git log --oneline --abbrev-commit --color main.."$mr"
				 git branch --list main -v
		      }
        done
}
main () {

    [ "$#" == "0" ] && action=list || { action="$1"; shift; }


    case "$action" in
        list|fetch|log)
            [ "$#" == "0" ] && remote="origin" || { remote="$1"; shift; }
            mr_"$action" "$remote" "$@"
            ;;
        help)
            mr_help
            ;;
        *)
            usage
            exit 1
            ;;
    esac

    exit 0
}



main "$@"
